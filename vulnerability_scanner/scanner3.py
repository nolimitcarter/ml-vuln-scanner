import os
import nmap
import json
import csv
import sqlite3
import requests
import zipfile
import io
import boto3
import concurrent.futures

def create_directory(path):
    if not os.path.exists(path):
        os.makedirs(path)

def download_nvd_data_from_s3(s3_bucket, s3_prefix, years):
    s3 = boto3.client('s3')
    create_directory("./nvd_data")
    for year in years:
        file_name = f"nvdcve-1.1-{year}.json"
        object_key = f"{s3_prefix}/{file_name}"
        
        try:
            s3.download_file(s3_bucket, object_key, f"./nvd_data/{file_name}")
            print(f"Downloaded {file_name} from S3 bucket {s3_bucket}")
        except Exception as e:
            print(f"Error: Could not download {file_name}. {e}")

def setup_database():
    conn = sqlite3.connect('vulnerabilities.db')
    cursor = conn.cursor()
    cursor.execute("DROP TABLE IF EXISTS vulnerabilities")
    cursor.execute('''CREATE TABLE vulnerabilities (
                        id TEXT PRIMARY KEY,
                        description TEXT,
                        cvss_score REAL,
                        cwe_id TEXT,
                        affected_products TEXT
                      )''')
    conn.commit()
    conn.close()

def parse_and_store_data(years):
    conn = sqlite3.connect('vulnerabilities.db')
    cursor = conn.cursor()
    for year in years:
        with open(f"./nvd_data/nvdcve-1.1-{year}.json", "r") as file:
            data = json.load(file)
            for item in data['CVE_Items']:
                cve_id = item['cve']['CVE_data_meta']['ID']
                description = item['cve']['description']['description_data'][0]['value']
                cvss_score = item.get('impact', {}).get('baseMetricV3', {}).get('cvssV3', {}).get('baseScore')

                if (item['cve']['problemtype']['problemtype_data'] and 
                    item['cve']['problemtype']['problemtype_data'][0]['description']):
                    cwe_id = item['cve']['problemtype']['problemtype_data'][0]['description'][0]['value']
                else:
                    cwe_id = None

                affected_products = []
                if 'configurations' in item:
                    nodes = item['configurations'].get('nodes', [])
                    for node in nodes:
                        if 'cpe_match' in node:
                            for match in node['cpe_match']:
                                affected_products.append(match['cpe23Uri'])

                affected_products_str = "; ".join(affected_products)

                cursor.execute("INSERT OR IGNORE INTO vulnerabilities (id, description, cvss_score, cwe_id, affected_products) VALUES (?, ?, ?, ?, ?)",
                               (cve_id, description, cvss_score, cwe_id, affected_products_str))
    conn.commit()
    conn.close()

def fetch_vulnerabilities(service, min_cvss_score=7.0):
    conn = sqlite3.connect('vulnerabilities.db')
    cursor = conn.cursor()
    query = f"{service.get('name', '')} {service.get('product', '')} {service.get('version', '')}".strip()

    cursor.execute("SELECT id, cvss_score, description FROM vulnerabilities WHERE affected_products LIKE ? AND cvss_score >= ?",
                   ('%' + query + '%', min_cvss_score))

    results = cursor.fetchall()
    conn.close()

    partial_matches = []
    for result in results:
        if service.get('version') and service.get('version') in result[2]:
            partial_matches.append(result[0])
        elif service.get('product') and service.get('product') in result[2]:
            partial_matches.append(result[0])
        elif service.get('name') in result[2]:
            partial_matches.append(result[0])

    return partial_matches

def identify_vulnerabilities(open_ports, min_cvss_score=7.0):
    vulnerabilities = {}
    for port, service in open_ports.items():
        partial_vulns = fetch_vulnerabilities(service, min_cvss_score)
        vulnerabilities[port] = partial_vulns
    return vulnerabilities

def scan_network(targets, ports):
    scanner = nmap.PortScanner()
    scanner.scan(targets, ports)

    scan_results = {}
    for host in scanner.all_hosts():
        scan_results[host] = {
            'status': scanner[host].state(),
            'tcp': {}
        }

        for proto in scanner[host].all_protocols():
            for p in scanner[host][proto].keys():
                scan_results[host]['tcp'][p] = scanner[host][proto][p]

    return scan_results

def print_results(scan_results, vulnerabilities):
    print("\n{:<15} {:<8} {:<10} {:<10} {:<10} {:<40}".format("IP Address", "Status", "SSH (22)", "HTTP (80)", "HTTPS (443)", "Vulnerabilities"))
    print("-" * 100)

    for ip, data in scan_results.items():
        status = data['status']
        ssh = data['tcp'].get(22, {}).get('state', 'N/A')
        http = data['tcp'].get(80, {}).get('state', 'N/A')
        https = data['tcp'].get(443, {}).get('state', 'N/A')
        vuln_list = vulnerabilities.get(ip, {})

        all_vulns = [vuln for port_vulns in vuln_list.values() for vuln in port_vulns]

        vuln_str_list = [str(vuln) for vuln in all_vulns]
        vuln_str = "; ".join(vuln_str_list)
        max_length = 60
        wrapped_vuln_list = "\n    ".join([vuln_str[i:i+max_length] for i in range(0, len(vuln_str), max_length)])
        
        print("{:<15} {:<8} {:<10} {:<10} {:<10} {:<40}".format(ip, status, ssh, http, https, wrapped_vuln_list))

def save_results_to_csv(scan_results, vulnerabilities, filename="./results/scan_results.csv"):
    create_directory(os.path.dirname(filename))
    with open(filename, 'w', newline='') as file:
        writer = csv.writer(file)
        writer.writerow(["IP Address", "Status", "SSH (22)", "HTTP (80)", "HTTPS (443)", "Vulnerabilities"])

        for ip, data in scan_results.items():
            status = data['status']
            ssh = data['tcp'].get(22, {}).get('state', 'N/A')
            http = data['tcp'].get(80, {}).get('state', 'N/A')
            https = data['tcp'].get(443, {}).get('state', 'N/A')
            vuln_list = vulnerabilities.get(ip, {})

            all_vulns = [vuln for port_vulns in vuln_list.values() for vuln in port_vulns]

            vuln_str_list = [str(vuln) for vuln in all_vulns]
            wrapped_vuln_list = "; ".join(vuln_str_list)
            writer.writerow([ip, status, ssh, http, https, wrapped_vuln_list])

def scan_networks_parallel(networks, ports):
    all_scan_results = {}

    with concurrent.futures.ThreadPoolExecutor() as executor:
        futures = {executor.submit(scan_network, network, ports): network for network in networks}

        for future in concurrent.futures.as_completed(futures):
            network = futures[future]
            try:
                result = future.result()
                all_scan_results[network] = result
            except Exception as exc:
                print(f"Network {network} scan generated an error: {exc}")

    return all_scan_results

def main():
    s3_bucket = "nolimitboostawsbucket"
    s3_prefix = "nvd_data"
    years = [2022, 2021, 2020, 2019]
    download_nvd_data_from_s3(s3_bucket, s3_prefix, years)
    setup_database()
    parse_and_store_data(years)

    networks = ["192.168.1.0/24", "172.26.174.0/24"]
    ports = "22,80,443"
    
    print("\nScanning networks, please wait...")
    results = scan_networks_parallel(networks, ports)

    for network, network_results in results.items():
        print(f"\nResults for {network}:")
        vulnerabilities = {ip: identify_vulnerabilities(data['tcp']) for ip, data in network_results.items()}
        print_results(network_results, vulnerabilities)
        save_results_to_csv(network_results, vulnerabilities, f"results/scan_results_{network.replace('/', '')}.csv")

    with open("results/scan_results.json", "w") as json_file:
        json.dump(results, json_file, indent=4)

    print("Scan complete. Results saved to CSV files and JSON.")

if __name__ == "__main__":
    main()

