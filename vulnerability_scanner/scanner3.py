import os
import nmap
import json
import csv
import sqlite3
import boto3
import concurrent.futures

def create_directory(path):
    if not os.path.exists(path):
        os.makedirs(path)

def stream_nvd_data_from_s3(s3_bucket, s3_prefix, years):
    s3 = boto3.client('s3')
    for year in years:
        file_name = f"nvdcve-1.1-{year}.json"
        object_key = f"{s3_prefix}/{file_name}"
        
        try:
            response = s3.get_object(Bucket=s3_bucket, Key=object_key)
            data = response['Body'].read()
            print(f"Streamed {file_name} from S3 bucket {s3_bucket}")
            yield data
        except Exception as e:
            print(f"Error: Could not stream {file_name}. {e}")

def setup_database():
    conn = sqlite3.connect('vulnerabilities.db')
    cursor = conn.cursor()
    cursor.execute("DROP TABLE IF EXISTS vulnerabilities")
    cursor.execute('''CREATE TABLE vulnerabilities (
                        id TEXT PRIMARY KEY,
                        description TEXT,
                        cvss_score REAL,
                        cwe_id TEXT,
                        affected_products TEXT,
                        version TEXT
                      )''')
    conn.commit()
    conn.close()

def parse_and_store_data(streamed_data):
    conn = sqlite3.connect('vulnerabilities.db')
    cursor = conn.cursor()
    for data in streamed_data:
        data = json.loads(data)
        for item in data['CVE_Items']:
            cve_id = item['cve']['CVE_data_meta']['ID']
            description = item['cve']['description']['description_data'][0]['value']
            cvss_score = item.get('impact', {}).get('baseMetricV3', {}).get('cvssV3', {}).get('baseScore')

            if (item['cve']['problemtype']['problemtype_data'] and 
                item['cve']['problemtype']['problemtype_data'][0]['description']):
                cwe_id = item['cve']['problemtype']['problemtype_data'][0]['description'][0]['value']
            else:
                cwe_id = None

            affected_products = []
            versions = []
            if 'configurations' in item:
                nodes = item['configurations'].get('nodes', [])
                for node in nodes:
                    if 'cpe_match' in node:
                        for match in node['cpe_match']:
                            affected_products.append(match['cpe23Uri'])
                            versions.append(match.get('versionEndIncluding', 'Unknown'))

            affected_products_str = "; ".join(affected_products)
            versions_str = "; ".join(set(versions))  # Deduplicate versions

            cursor.execute("INSERT OR IGNORE INTO vulnerabilities (id, description, cvss_score, cwe_id, affected_products, version) VALUES (?, ?, ?, ?, ?, ?)",
                           (cve_id, description, cvss_score, cwe_id, affected_products_str, versions_str))
    conn.commit()
    conn.close()

def fetch_vulnerabilities(service, version=None, min_cvss_score=7.0):
    conn = sqlite3.connect('vulnerabilities.db')
    cursor = conn.cursor()

    product_query = f"%{service.get('product', '')}%"
    version_query = f"%{version}%" if version else "%"

    cursor.execute(""" 
        SELECT id, cvss_score, description, affected_products, version 
        FROM vulnerabilities
        WHERE affected_products LIKE ? AND version LIKE ? AND cvss_score >= ?""",
        (product_query, version_query, min_cvss_score)
    )

    results = cursor.fetchall()
    conn.close()

    matching_vulns = [result[0] for result in results if result[1] is not None]  # Only include valid CVEs with score
    return matching_vulns

def identify_vulnerabilities(open_ports, min_cvss_score=7.0):
    if not isinstance(open_ports, dict):
        print(f"Warning: Expected dictionary but got {type(open_ports)}. Skipping vulnerability check.")
        return {}

    vulnerabilities = {}
    for port, service in open_ports.items():
        # Add more logic here to filter out wrong versions or unnecessary ports
        matching_vulns = fetch_vulnerabilities(service, service.get('version'), min_cvss_score)
        if matching_vulns:
            vulnerabilities[port] = matching_vulns
    return vulnerabilities

def scan_network(targets, ports):
    scanner = nmap.PortScanner()
    scanner.scan(targets, ports)

    scan_results = {}
    for host in scanner.all_hosts():
        scan_results[host] = {
            'status': scanner[host].state(),
            'tcp': {}  # Ensures data['tcp'] is always a dictionary
        }

        for proto in scanner[host].all_protocols():
            if proto == "tcp":
                for p in scanner[host][proto].keys():
                    scan_results[host]['tcp'][p] = scanner[host][proto][p]

    return scan_results

def print_results(scan_results, vulnerabilities):
    print("\n{:<15} {:<8} {:<10} {:<10} {:<10} {:<40}".format("IP Address", "Status", "SSH (22)", "HTTP (80)", "HTTPS (443)", "Vulnerabilities"))
    print("-" * 100)

    for ip, data in scan_results.items():
        status = data['status']
        ssh = data['tcp'].get(22, {}).get('state', 'N/A')
        http = data['tcp'].get(80, {}).get('state', 'N/A')
        https = data['tcp'].get(443, {}).get('state', 'N/A')
        vuln_list = vulnerabilities.get(ip, {})

        all_vulns = [vuln for port_vulns in vuln_list.values() for vuln in port_vulns]
        vuln_str = "; ".join(all_vulns)[:60]  # Truncate long vuln lists

        print("{:<15} {:<8} {:<10} {:<10} {:<10} {:<40}".format(ip, status, ssh, http, https, vuln_str))

def save_results_to_csv(scan_results, vulnerabilities, filename="./results/scan_results.csv"):
    create_directory(os.path.dirname(filename))
    with open(filename, 'w', newline='') as file:
        writer = csv.writer(file)
        writer.writerow(["IP Address", "Status", "SSH (22)", "HTTP (80)", "HTTPS (443)", "Vulnerabilities"])

        for ip, data in scan_results.items():
            status = data['status']
            ssh = data['tcp'].get(22, {}).get('state', 'N/A')
            http = data['tcp'].get(80, {}).get('state', 'N/A')
            https = data['tcp'].get(443, {}).get('state', 'N/A')
            vuln_list = vulnerabilities.get(ip, {})

            all_vulns = [vuln for port_vulns in vuln_list.values() for vuln in port_vulns]
            vuln_str = "; ".join(all_vulns)

            writer.writerow([ip, status, ssh, http, https, vuln_str])

def scan_networks_parallel(networks, ports):
    all_scan_results = {}

    with concurrent.futures.ThreadPoolExecutor() as executor:
        futures = {executor.submit(scan_network, network, ports): network for network in networks}

        for future in concurrent.futures.as_completed(futures):
            network = futures[future]
            try:
                result = future.result()
                all_scan_results[network] = result
            except Exception as exc:
                print(f"Network {network} scan generated an error: {exc}")

    return all_scan_results

def main():
    s3_bucket = "nolimitboostawsbucket"
    s3_prefix = "nvd_data"
    years = [2023, 2024, 2022, 2021, 2020, 2019]
    streamed_data = stream_nvd_data_from_s3(s3_bucket, s3_prefix, years)
    setup_database()
    parse_and_store_data(streamed_data)

    networks = ["192.168.1.0/24", "172.26.174.0/24"]
    ports = "22,80,443"

    print("\nScanning networks, please wait...")
    results = scan_networks_parallel(networks, ports)

    for network, network_results in results.items():
        vulnerabilities = {ip: identify_vulnerabilities(data['tcp']) for ip, data in network_results.items()}
        print_results(network_results, vulnerabilities)
        save_results_to_csv(network_results, vulnerabilities, f"results/scan_results_{network.replace('/', '')}.csv")

    print("Scan complete. Results saved.")

if __name__ == "__main__":
    main()

